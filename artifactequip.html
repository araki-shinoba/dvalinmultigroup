<html><head><meta charset="utf-8"><title>聖遺物調整</title><meta name="viewport" content="width=device-width,user-scalable=0"><meta name="robots" content="noindex,nofollow,noarchive"><style type="text/css">
/*▼▼▼共通▼▼▼*/
body{font-size:12px;color:#444;}
table{font-size:12px;border:1px #888 solid;border-collapse:collapse;margin:0 auto;}

label span{border:1px solid #aaa;border-radius:1rem;padding:4px 8px;display:inline-block;}
input[type=checkbox]{display:none;}
input[type=checkbox]:checked ~ span{background:#aaa;color:#fff;}

/*▼▼▼更新履歴▼▼▼*/
div.updatehistory > div.version{font-weight:bold;font-size:1.5rem;border-bottom:1px #888 solid;padding:0.25rem;margin:0.25rem;}
div.updatehistory > div.version > a{font-size:1.5rem;}
div.updatehistory > div.version > span{display:inline-block;margin:0 1rem 0 0.5rem;font-weight:normal;font-size:12px;}
div.updatehistory > div.details{margin:0 0 2rem 2rem;}
div.updatehistory > div.details > p{margin:0 0 0.5rem;}

/*▼▼▼CSV入力欄▼▼▼*/
.csv-editor {
  position: relative;
  width: 100%;
  height: 300px;
  font-family: monospace;
  font-size: 14px;
  line-height: 20px;
  box-sizing: border-box;
}

.csv-editor .csv-view,
.csv-editor .csv-input {
  position: absolute;
  inset: 0;
  box-sizing: border-box;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  padding: 4px 8px;
  white-space: pre;
  overflow: auto;
}

.csv-editor .csv-input {
  background: transparent;
  color: transparent;
  caret-color: black;
  z-index: 2;
  resize: none;
}

.csv-editor .csv-view {
  z-index: 1;
  pointer-events: none;
  word-break: break-word; /* 長い文字列でも崩れないように */
  border:1px solid transparent;
}

.csv-editor .csv-view .csv-line {
  height: 20px; /* textarea の line-height に合わせる */
  line-height: 20px;
}

.colA1 {background:#fdf;}.colB1 {background:#fdf;}
.colA2 {background:#fdf;}.colB2 {background:#fdf;}
.colA3 {background:#fdf;}.colB3 {background:#fdd;}
.colA4 {background:#fdd;}.colB4 {background:#fdd;}
.colA5 {background:#fdd;}.colB5 {background:#fdd;}
.colA6 {background:#ffd;}.colB6 {background:#ffd;}
.colA7 {background:#ffd;}.colB7 {background:#ffd;}
.colA8 {background:#dfd;}.colB8 {background:#dfd;}
.colA9 {background:#dfd;}
.colA10{background:#dff;}
.colA11{background:#dff;}
.colA12{background:#ddf;}
.colA13{background:#ddf;}
.csv-view .comment{background:#ddd;}
.csv-view .header{background:#eef;}
</style></head><body>

<div style="max-width:1000px;margin:0 auto;">
	<div style="background:#444;padding:0.5rem;color:#fff;text-align:center;">1.名前を入力する</div>
	<div style="margin:0.5rem;text-align:center;">
		ユーザー名：<input id="username" placeholder="username"><button id="showUser">表示</button>
		<div id="currentUserName" style="margin:0.5rem;"></div>
	</div>

	<div style="background:#444;padding:0.5rem;color:#fff;text-align:center;margin-top:3rem;">2.聖遺物情報を登録する</div>
	<div style="margin:0.5rem 0;text-align:center;font-size:12px;">
		<span class="colA1">聖遺物名</span>,<span class="colA2">部位</span>,<span class="colA3">メインOP</span>,<span class="colA4">HP+</span>,<span class="colA5">HP%</span>,<span class="colA6">攻撃力+</span>,<span class="colA7">攻撃力%</span>,<span class="colA8">防御力+</span>,<span class="colA9">防御力%</span>,<span class="colA10">会心率%</span>,<span class="colA11">会心ダメージ%</span>,<span class="colA12">元素熟知+</span>,<span class="colA13">元素チャージ効率%</span><br><br>
		<details><summary style="background:#ddd;padding:0.25rem;">入力のルールについて</summary>
			<pre>ex:<span class="colA1">                  </span>,<span class="colA2">  </span>,<span class="colA3">       </span>,<span class="colA4">HP+</span>,<span class="colA5">HP% </span>,<span class="colA6">攻</span>,<span class="colA7">攻% </span>,<span class="colA8">防</span>,<span class="colA9">防% </span>,<span class="colA10"> 率 </span>,<span class="colA11">ダメ</span>,<span class="colA12">熟</span>,<span class="colA13">元ﾁｬ</span><br>ex:<span class="colA1">剣闘士のフィナーレ</span>,<span class="colA2">花</span>,<span class="colA3">HP+    </span>,<span class="colA4">   </span>,<span class="colA5">    </span>,<span class="colA6">  </span>,<span class="colA7">15.7</span>,<span class="colA8">  </span>,<span class="colA9">11.7</span>,<span class="colA10">10.9</span>,<span class="colA11"> 7.7</span>,<span class="colA12">  </span>,<span class="colA13">    </span><br>ex:<span class="colA1">教官              </span>,<span class="colA2">羽</span>,<span class="colA3">攻撃力+</span>,<span class="colA4">   </span>,<span class="colA5">    </span>,<span class="colA6">  </span>,<span class="colA7"> 4.2</span>,<span class="colA8">  </span>,<span class="colA9">    </span>,<span class="colA10"> 8.1</span>,<span class="colA11"> 5.0</span>,<span class="colA12">17</span>,<span class="colA13">    </span></pre>
			<table border="1">
				<tr><th>聖遺物名<td>「剣闘士」「火魔女」など省略して表記することもできますが、同一の聖遺物はすべて同じ表記にしてください<br>ここが無記入の行は計算の際に無視されます
				<tr><th>部位    <td>「花」「羽」「砂」「杯」「冠」の5文字のみ対応しています
				<tr><th>メインOP<td>「炎ダメ」「治癒」など省略して表記することもできますが、同一のメインOPは全て同じ表記にしてください
				<tr><th>サブOP  <td>入力されていない箇所は0として扱われます
				<tr><th>        <td>見た目を整える場合は半角空白を使用してください<br>全角空白や全角数字はすべて自動で半角に置換されます<br>読点(、)はすべて自動でカンマ(,)に置換されます
				<tr><th>        <td>「//」を入力すると、その行のそれ以降の文字はすべてコメントアウトとして扱われます
			</table>
		</details>
	</div>
	<div class="csv-editor">
		<div class="csv-view"></div>
		<textarea id="artifact" class="csv-input"></textarea>
	</div>

	<div style="background:#444;padding:0.5rem;color:#fff;text-align:center;margin-top:3rem;">3.キャラ情報を登録する</div>
	<div style="margin:0.5rem 0;text-align:center;font-size:12px;">
		<span class="colB1">キャラクター名</span>,<span class="colB2">4or2x2セットの名前</span>,<span class="colB3">砂メインOP</span>,<span class="colB4">杯メインOP</span>,<span class="colB5">冠メインOP</span>,<span class="colB6">会心率上限値</span>,<span class="colB7">元素チャージ効率下限値</span>,<span class="colB8">スコア計算式</span><br><br>
		<details><summary style="background:#ddd;padding:0.25rem;">入力のルールについて</summary>
			<pre>ex:<span class="colB1">    </span>,<span class="colB2">セット名             </span>,<span class="colB3">砂メインOP       </span>,<span class="colB4">杯メインOP     </span>,<span class="colB5">冠メインOP</span>,<span class="colB6">率上限</span>,<span class="colB7">チャージ下限        </span>,<span class="colB8">スコア計算式</span><br>ex:<span class="colB1">香菱</span>,<span class="colB2">絶縁の旗印           </span>,<span class="colB3">元素チャージ効率%</span>,<span class="colB4">炎元素ダメージ%</span>,<span class="colB5">会心率%   </span>,<span class="colB6">100-5 </span>,<span class="colB7">250-100-51.8-45.9-20</span>,<span class="colB8">攻撃+会心   </span><br>ex:<span class="colB1">鍾離</span>,<span class="colB2">千岩牢固/花海甘露の光</span>,<span class="colB3">HP%              </span>,<span class="colB4">HP%            </span>,<span class="colB5">HP%       </span>,<span class="colB6">100-5 </span>,<span class="colB7">140-100             </span>,<span class="colB8">HP+会心     </span><br>参考：香菱の元素チャージは250(要求チャージ)-100(自前のチャージ)-51.8(チャージ時計)-45.9(漁獲)-20(絶縁2セット)を入力しています</pre>
			<table border="1">
				<tr><th>キャラクター名        <td>ここが無記入の行は計算の際に無視されます
				<tr><th>セット名              <td>聖遺物情報に登録した名前を書いてください(例：聖遺物情報に「火魔女」と書いた場合、こちらでも「火魔女」と書く必要がある)<br>半角スラッシュを使うと、2セットx2の計算ができます
				<tr><th>メインOP              <td>聖遺物情報に登録した名前を書いてください(例：聖遺物情報に「炎ダメ」と書いた場合、こちらでも「炎ダメ」と書く必要がある)
				<tr><th>会心率上限値          <td>ここに入力された数値を上回らないようにサブOPが制限されます<br>四則演算に対応しています
				<tr><th>元素チャージ効率下限値<td>ここに入力された数値を上回るようにサブOPが制限されます<br>四則演算に対応しています
				<tr><th>スコア計算式          <td>スコア計算式に入力できる文字列は「HP」「攻撃」「攻撃力」「防御」「防御力」「会心」「率ダメ」「元素熟知」「熟知」「元素チャージ効率」「チャージ効率」「チャージ」「元チャ」の13種類です。これ以外の表記には対応していません
				<tr><th>                      <td>上に書いたキャラクターから優先して聖遺物が選ばれます。アタッカー等、優先したいキャラクターを上に書くようにしてください
				<tr><th>                      <td>見た目を整える場合は半角空白を使用してください<br>全角空白や全角数字はすべて自動で半角に置換されます<br>読点(、)はすべて自動でカンマ(,)に置換されます
				<tr><th>                      <td>行頭に「#」を入力すると、その行は見出しとして扱われます<br>「//」を入力すると、その行のそれ以降の文字はすべてコメントアウトとして扱われます
			</table>
		</details>
	</div>
	<div class="csv-editor">
		<div class="csv-view"></div>
		<textarea id="character" class="csv-input"></textarea>
	</div>
	<div style="margin:0.5rem;text-align:center;">
		<label><input type="checkbox" id="chkReduceCrExpr"><span>計算の際に会心率上限値から初期値5を引く</span></label>
		<label><input type="checkbox" id="chkReduceErExpr"><span>計算の際に元素チャージ効率下限値から初期値100を引く</span></label>
	</div>

	<div style="margin:3rem 0 0.5rem;text-align:center;">
		<button id="run">計算</button><br>
		<progress id="progress" value="0" max="1" style="width:300px;margin-top:1rem;"></progress><br>
		<span id="progressText"></span>
	</div>

	<div style="background:#444;padding:0.5rem;color:#fff;text-align:center;margin-top:3rem;">4.計算結果</div>
	<pre id="result" style="border:1px #aaa solid;min-height:3rem;"></pre>
</div>

<script type="module">
//▼▼▼Firebaseの初期設定(編集不可)▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, onValue, update, get, remove, off } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyC9568YUDsHERrjArZrrgiseI_j5z3YPJ0",
  authDomain: "artifactequip.firebaseapp.com",
  databaseURL: "https://artifactequip-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "artifactequip",
  storageBucket: "artifactequip.firebasestorage.app",
  messagingSenderId: "677641283387",
  appId: "1:677641283387:web:1239e51d20b5ca1704b91e",
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
//▲▲▲Firebase初期設定(編集不可)▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

//▼▼▼CSVの着色▼▼▼
function escapeHtml(str){
  return str
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");
}

function normalizeCsvText(str){
  return str
    // 全角数字 → 半角数字
    .replace(/[０-９]/g, s =>
      String.fromCharCode(s.charCodeAt(0) - 0xFEE0)
    )
    // 全角空白 → 半角空白
    .replace(/\u3000/g, " ")
    // 全角カンマ「、」 → 半角カンマ「,」
    .replace(/、/g, ",");
}
/* ==============================
   CSVビュー共通描画
============================== */
function renderCsvLineWithLineComment(line, prefix){

  // 見出し行
  if (line.startsWith("#")) {
    return `<span class="header">${escapeHtml(line)}</span>`;
  }

  let html = "";

  const commentPos = line.indexOf("//");

  let normalPart;
  let commentPart;

  if(commentPos === -1){
    normalPart  = line;
    commentPart = "";
  }else{
    normalPart  = line.slice(0, commentPos);
    commentPart = line.slice(commentPos);
  }

  let col = 0;

  const cols = normalPart.split(",");

  for(let i=0;i<cols.length;i++){
    html += `<span class="cell ${prefix}${(col % 13)+1}">${escapeHtml(cols[i])}</span>`;
    if(i < cols.length - 1){
      html += ",";
      col++;
    }
  }

  if(commentPart){
    html += `<span class="comment">${escapeHtml(commentPart)}</span>`;
  }

  return html;
}

function renderCsvEditors() {
  document.querySelectorAll(".csv-editor").forEach(editor => {
    const input = editor.querySelector(".csv-input");
    const view  = editor.querySelector(".csv-view");

    // 入力を正規化
    const normalized = normalizeCsvText(input.value);
    if (input.value !== normalized) input.value = normalized;

    // 改行ごとに <div> でラップして高さを揃える
    const lines = input.value.split(/\r?\n/);
    const prefix = input.id === "artifact" ? "colA" :
                   input.id === "character" ? "colB" : "col";

    // 既存の行要素を取得
    const existingLines = Array.from(view.querySelectorAll(".csv-line"));

    // 各行を div でラップして描画
    lines.forEach((line, i) => {
      const cols = line.split(",");
      const html = renderCsvLineWithLineComment(line, prefix);
      if (existingLines[i]) {
        // 変更がある場合のみ更新
        if (existingLines[i].innerHTML !== html) existingLines[i].innerHTML = html;
      } else {
        // 新しい行を追加
        const div = document.createElement("div");
        div.className = "csv-line";
        div.innerHTML = html;
        view.appendChild(div);
      }
    });

    // 古い行が残っている場合は削除
    for (let i = lines.length; i < existingLines.length; i++) {
      view.removeChild(existingLines[i]);
    }

    // 高さを textarea に合わせる
    const lineHeight = parseFloat(getComputedStyle(input).lineHeight);
    view.querySelectorAll(".csv-line").forEach(div => div.style.height = lineHeight + "px");

    // スクロール同期
    view.scrollTop = input.scrollTop;
    view.scrollLeft = input.scrollLeft;
  });
}

/* ==============================
   各csv-editorの入力処理
============================== */
document.querySelectorAll(".csv-editor").forEach(editor => {

  const input = editor.querySelector(".csv-input");
  const view  = editor.querySelector(".csv-view");

  input.addEventListener("input", () => {

    // カーソル位置保持
    const start = input.selectionStart;
    const end   = input.selectionEnd;

    const normalized = normalizeCsvText(input.value);

    if (input.value !== normalized) {
      input.value = normalized;
      input.setSelectionRange(start, end);
    }

    renderCsvEditors();
  });

  input.addEventListener("scroll", () => {
    view.scrollTop  = input.scrollTop;
    view.scrollLeft = input.scrollLeft;
  });
});

// 初期描画
renderCsvEditors();


//▼▼▼聖遺物リストCSVからの計算▼▼▼
function parseCSV(text) {

  const lines = text
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(l => l !== "");

  return lines.map((line, i) => {

    const c = line.split(",").map(v => v.trim());

    if (c.length < 13) return null;

    const crRate = Number(c[9]);
    const cdRate = Number(c[10]);

    return {
      id   : i,
      set  : c[0],
      slot : c[1],
      main : c[2],

      hpFlat  : Number(c[3]),
      hpRate  : Number(c[4]),
      atkFlat : Number(c[5]),
      atkRate : Number(c[6]),
      defFlat : Number(c[7]),
      defRate : Number(c[8]),
      crRate,
      cdRate,
      emFlat  : Number(c[11]),
      erRate  : Number(c[12]),

      cri : crRate * 2 + cdRate,

      // 追加（高速化用）
      _score : 0,
      _setId : -1
    };

  }).filter(x => x !== null);
}

function parseSetRule(text) {
  const rules = [];
  if (!text.trim()) return rules;

  const parts = text.split(",");

  for (const p of parts) {
    const [name, cnt] = p.split(":");
    rules.push({
      name: name.trim(),
      count: Number(cnt)
    });
  }

  return rules;
}

function buildScoreFn(block) {

  const useHP  = block.querySelector(".useHP").checked;
  const useATK = block.querySelector(".useATK").checked;
  const useCRI = block.querySelector(".useCRI").checked;
  const useDEF = block.querySelector(".useDEF").checked;
  const useEM  = block.querySelector(".useEM").checked;
  const useER  = block.querySelector(".useER").checked;

  return function(a) {

    let s = 0;

    if (useHP)  s += a.hp;
    if (useATK) s += a.atk;
    if (useCRI) s += a.cri;
    if (useDEF) s += a.def;
    if (useEM)  s += a.em / 4;
    if (useER)  s += a.er;

    return s;
  };
}

// -----------------------------------------
// セットケースを作る
// cond.setRules: [{id,count}] 例: 4セットまたは2+2
// slots: ["花","羽","砂","杯","冠"]
// -----------------------------------------
function buildSetCases(cond) {
  const slots = ["花","羽","砂","杯","冠"];
  const rules = cond.setRules;

  const cases = [];

  if (rules.length === 1) {
    // 4セットパターン
    const S = rules[0].id;
    // 5スロットから4個選ぶ場合 + 5個全部
    const choose4 = [
      [0,1,2,3],[0,1,2,4],[0,1,3,4],[0,2,3,4],[1,2,3,4]
    ];
    for (const sel of choose4) {
      const slotMap = {};
      slots.forEach((s,i)=>slotMap[s]= sel.includes(i)? S : -1);
      cases.push(slotMap);
    }
    // 5個全部
    const slotMapAll = {};
    slots.forEach(s=>slotMapAll[s]=S);
    cases.push(slotMapAll);
  } else if (rules.length === 2) {
    // 2+2パターン
    const A = rules[0].id;
    const B = rules[1].id;
    // 5スロットからA2,B2配置パターンを生成
    // 5スロット: 5C2=10でAの位置, 残りからB2選択
    const slotIndices = [0,1,2,3,4];
    for (let i1=0;i1<4;i1++){
      for (let i2=i1+1;i2<5;i2++){
        const aSlots = [i1,i2];
        const remaining = slotIndices.filter(x=>!aSlots.includes(x));
        for (let j1=0;j1<remaining.length-1;j1++){
          for (let j2=j1+1;j2<remaining.length;j2++){
            const bSlots = [remaining[j1],remaining[j2]];
            const slotMap = {};
            slots.forEach((s,i)=>{
              if(aSlots.includes(i)) slotMap[s]=A;
              else if(bSlots.includes(i)) slotMap[s]=B;
              else slotMap[s]=-1;
            });
            cases.push(slotMap);
          }
        }
      }
    }
  }

  return cases;
}

// -----------------------------------------
// 内側探索用の findBestBuildCase
// - setCnt や setRules チェック不要
// - slotMap に従い、候補配列をフィルタして探索
// -----------------------------------------

// 小数第二位で丸める関数
function round1(x) {
  return Math.round(x * 10) / 10;
}

async function findBestBuildCase(data, cond, onProgress, setIdCount) {

  const cases = buildSetCases(cond);

  let bestOverall = null;
  let foundAnyOverall = false;

  let hasSetOK  = false;
  let hasEROK   = false;
  let hasCROK   = false;
  let bestMinCR = Infinity; // 暫定：最小会心率
  let bestMaxER = 0;       // 暫定：最大元素チャージ

  for(const slotMap of cases){

    const flowers = data.filter(a => a.slot === "花" && (slotMap["花"]===-1 || a._setId===slotMap["花"]));
    const plumes  = data.filter(a => a.slot === "羽" && (slotMap["羽"]===-1 || a._setId===slotMap["羽"]));
    const sands   = data.filter(a => a.slot === "砂" && (slotMap["砂"]===-1 || a._setId===slotMap["砂"]) && a.main===cond.sandMain);
    const goblets = data.filter(a => a.slot === "杯" && (slotMap["杯"]===-1 || a._setId===slotMap["杯"]) && a.main===cond.gobletMain);
    const circs   = data.filter(a => a.slot === "冠" && (slotMap["冠"]===-1 || a._setId===slotMap["冠"]) && a.main===cond.circletMain);

    const minER = round1(Math.max(0, cond.erRequired - cond.erFromOther));
    const maxCR = round1(cond.crMax);

    // セットだけ成立する組み合わせが存在するか
    if(flowers.length && plumes.length && sands.length && goblets.length && circs.length){
      hasSetOK = true;
    }

    // スコア事前計算
    for(const a of data) a._score = cond.scoreFn(a);

    flowers.sort((a,b)=>b._score-a._score);
    plumes.sort((a,b)=>b._score-a._score);
    sands.sort((a,b)=>b._score-a._score);
    goblets.sort((a,b)=>b._score-a._score);
    circs.sort((a,b)=>b._score-a._score);

    const maxBySlot = { "花":0,"羽":0,"砂":0,"杯":0,"冠":0 };
    for(const a of data){
      const s = a._score;
      if(s>maxBySlot[a.slot]) maxBySlot[a.slot]=s;
    }

    let maxCircER = 0;
    for(const c of circs){
      if(c.erRate>maxCircER) maxCircER=c.erRate;
    }

    const totalFP = flowers.length*plumes.length;
    let doneFP = 0;
    let tick = 0;

    for(const f of flowers){
      const sf = f._score;

      for(const p of plumes){

        doneFP++;
        if(onProgress) onProgress(doneFP/totalFP);

        if((++tick & 1023)===0) await new Promise(r=>setTimeout(r,0));

        const sp = p._score;
        const upperFP = sf + sp + maxBySlot["砂"] + maxBySlot["杯"] + maxBySlot["冠"];
        if(bestOverall && upperFP<=bestOverall.total) continue;

        for(const s of sands){

          const sps = sf+sp+s._score;
          const upperFPS = sps + maxBySlot["杯"] + maxBySlot["冠"];
          if(bestOverall && upperFPS<=bestOverall.total) continue;

          const er3 = f.erRate + p.erRate + s.erRate;
          const cr3 = f.crRate + p.crRate + s.crRate;
          if(cr3>maxCR) continue;

          for(const g of goblets){

            const sg = g._score;
            const upper4 = sps+sg+maxBySlot["冠"];
            if(bestOverall && upper4<=bestOverall.total) continue;

            const er4 = er3+g.erRate;
            const cr4 = cr3+g.crRate;

            // -------------------------------
            //  会心率条件は ER と独立して判定
            // -------------------------------
            if(!hasCROK){
              for(const c2 of circs){
                if(cr4 + c2.crRate <= maxCR){
                  hasCROK = true;
                  break;
                }
              }
            }

            // ★ ここで暫定値を記録（枝刈りより前）
            //   セット構成＋メイン一致のみ満たす全組み合わせ
            for(const c2 of circs){
              const crTmp = cr4 + c2.crRate;
              const erTmp = er4 + c2.erRate;

              if(crTmp < bestMinCR) bestMinCR = crTmp;
              if(erTmp > bestMaxER) bestMaxER = erTmp;
            }

            // 以降は従来どおり探索用の枝刈り
            if(er4 + maxCircER < minER) continue;
            if(cr4 > maxCR) continue;

            for(const c of circs){

              const erSum = er4 + c.erRate;
              const crSum = cr4 + c.crRate;

              //  ER 条件も独立して検出
              if(erSum >= minER) hasEROK = true;
              if(erSum < minER) continue;
              if(crSum > maxCR) continue;

              const total = sps + sg + c._score;
              foundAnyOverall = true;

              if(!bestOverall || total > bestOverall.total){
                bestOverall = { total, list:[f,p,s,g,c], erSum, crSum };
              }
            }
          }
        }
      }
    }
  }

  return {
    best     : bestOverall,
    foundAny: foundAnyOverall,
    minER   : round1(Math.max(0, cond.erRequired - cond.erFromOther)),
    maxCR   : round1(cond.crMax),
    hasSetOK,
    hasEROK,
    hasCROK,
    bestMinCR : round1(bestMinCR),
    bestMaxER : round1(bestMaxER)
  };
}

// -----------------------------
// キャラCSVを読む
// -----------------------------
function parseCharacterCSVWithHeader(text){

  const rows = [];
  const lines = text.split(/\r?\n/);

  for (const raw of lines) {

    // まずコメントだけ除去（空白は消さない）
    const noComment = raw.replace(/\/\/.*$/, "");

    // 空行判定は trim でOK
    if (!noComment.trim()) continue;

    // 見出し行（# は必ず行頭のみ）
    if (noComment.startsWith("#")) {
      rows.push({
        type: "header",
        text: noComment.slice(1).trim()
      });
      continue;
    }

    rows.push({
      type: "csv",
      text: noComment.trim()
    });
  }

  return rows;
}

function parseCharacterCSV(text){

  const lines = text
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(l => l !== "");

  return lines.map((line, i) => {

    const c = line.split(",").map(v => v.trim());

    if (c.length < 8) return null;

    const [
      name,
      setText,
      sandMain,
      gobletMain,
      circletMain,
      crExpr,
      erExpr,
      scoreExpr
    ] = c;

    // name が空欄の場合は計算せずスキップ
    if (!name) return null;

    // チェック状態を取得
    const reduceCR = document.getElementById("chkReduceCrExpr")?.checked;
    const reduceER = document.getElementById("chkReduceErExpr")?.checked;

    // 式を補正（仕様通り、式として差し引く）
    const crExpr2 = reduceCR ? `(${crExpr})-5`   : crExpr;
    const erExpr2 = reduceER ? `(${erExpr})-100` : erExpr;

    return {
      name,
      setRules   : parseSetFromShort(setText),
      sandMain,
      gobletMain,
      circletMain,
      crMax      : evalSimpleExpr(crExpr2),
      erRequired : evalSimpleExpr(erExpr2),
      scoreFn    : buildScoreFnFromText(scoreExpr),
      scoreExpr  : scoreExpr
    };

  }).filter(x => x !== null);
}

// -----------------------------
// 4セット or 2+2 記法
// -----------------------------
function parseSetFromShort(text){

  if(!text) return [];

  if(text.includes("/")){
    const [a,b] = text.split("/").map(s => s.trim());
    return [
      { name:a, count:2 },
      { name:b, count:2 }
    ];
  }

  return [
    { name:text.trim(), count:4 }
  ];
}

// -----------------------------
// 四則演算だけ許可
// -----------------------------
function evalSimpleExpr(expr){

  if(!expr) return 0;

  const s = expr.replace(/\s+/g,"");

  if(!/^[0-9+\-*/().]+$/.test(s)){
    return Number(expr) || 0;
  }

  try{
    return Function("return (" + s + ")")();
  }catch(e){
    return Number(expr) || 0;
  }
}

// -----------------------------
// スコア式
// -----------------------------
function buildScoreFnFromText(text){

  if(!text) return () => 0;

  const map = {
    "HP"       : "a.hpRate",

    "攻撃"     : "a.atkRate",
    "攻撃力"   : "a.atkRate",

    "防御"     : "a.defRate",
    "防御力"   : "a.defRate",

    "会心"     : "(a.crRate*2+a.cdRate)",
    "率ダメ"   : "(a.crRate*2+a.cdRate)",

    "元素熟知" : "(a.emFlat/4)",
    "熟知"     : "(a.emFlat/4)",

    "元素チャージ効率" : "a.erRate",
    "チャージ効率"     : "a.erRate",
    "チャージ"         : "a.erRate",
    "元チャ"           : "a.erRate"
  };

  let expr = text;

  for(const k in map){
    expr = expr.split(k).join(map[k]);
  }

if(!/^[a-zA-Z0-9_.*+()\/\- ]+$/.test(expr)){
    return () => 0;
  }

  try{
    return new Function("a", "return " + expr + ";");
  }catch(e){
    return () => 0;
  }
}

// -----------------------------
// 実行
// -----------------------------
function buildSubOpText(a){

  const list = [];

  if (!isNaN(a.hpFlat) && a.hpFlat !== 0) list.push(`HP+${a.hpFlat.toFixed(0)}`);
  if (!isNaN(a.hpRate) && a.hpRate !== 0) list.push(`HP${a.hpRate.toFixed(1)}%`);
  if (!isNaN(a.atkFlat) && a.atkFlat !== 0) list.push(`攻撃力+${a.atkFlat.toFixed(0)}`);
  if (!isNaN(a.atkRate) && a.atkRate !== 0) list.push(`攻撃力${a.atkRate.toFixed(1)}%`);
  if (!isNaN(a.defFlat) && a.defFlat !== 0) list.push(`防御力+${a.defFlat.toFixed(0)}`);
  if (!isNaN(a.defRate) && a.defRate !== 0) list.push(`防御力${a.defRate.toFixed(1)}%`);
  if (!isNaN(a.crRate) && a.crRate !== 0) list.push(`会心率${a.crRate.toFixed(1)}%`);
  if (!isNaN(a.cdRate) && a.cdRate !== 0) list.push(`会心ダメージ${a.cdRate.toFixed(1)}%`);
  if (!isNaN(a.emFlat) && a.emFlat !== 0) list.push(`元素熟知${a.emFlat.toFixed(0)}`);
  if (!isNaN(a.erRate) && a.erRate !== 0) list.push(`元素チャージ効率${a.erRate.toFixed(1)}%`);

  return list.join(",");
}

function sumSubStats(list){

  const s = {
    hpFlat:0, hpRate:0,
    atkFlat:0, atkRate:0,
    defFlat:0, defRate:0,
    crRate:0, cdRate:0,
    emFlat:0, erRate:0
  };

  for(const a of list){
    s.hpFlat  += a.hpFlat;
    s.hpRate  += a.hpRate;
    s.atkFlat += a.atkFlat;
    s.atkRate += a.atkRate;
    s.defFlat += a.defFlat;
    s.defRate += a.defRate;
    s.crRate  += a.crRate;
    s.cdRate  += a.cdRate;
    s.emFlat  += a.emFlat;
    s.erRate  += a.erRate;
  }

  return s;
}

document.getElementById("run").addEventListener("click", async () => {

  const bar  = document.getElementById("progress");
  const text = document.getElementById("progressText");

  let data = parseCSV(
    document.getElementById("artifact").value
    .replace(/\/\/.*$/gm, "")
  );

  const characterRows = parseCharacterCSVWithHeader(
    document.getElementById("character").value
  );

  // 実際に計算するキャラ行だけ
  const characters = parseCharacterCSV(
    characterRows
      .filter(r => r.type === "csv")
      .map(r => r.text)
      .join("\n")
  );

  // -----------------------------
  // セット名 → ID 変換（全体で一度だけ）
  // -----------------------------
  const setIdMap = new Map();
  let setIdCount = 0;

  for (const a of data) {
    if (!setIdMap.has(a.set)) {
      setIdMap.set(a.set, setIdCount++);
    }
    a._setId = setIdMap.get(a.set);
  }

  let result = "";

  bar.value = 0;
  text.textContent = "0.0%";

  const totalChars = characters.length;

  let charIndex = 0;

  for (const row of characterRows) {

    // 見出し
    if (row.type === "header") {

      result +=
        `<div style="background:#aaa;color:#fff;padding:0.5rem;margin:2rem 0;">` +
        `${row.text}` +
        `</div>`;

      continue;
    }

    const ch = characters[charIndex];

    if (!ch) {
      // CSVとして無効な行なのでスキップ
      continue;
    }

    const i  = charIndex;
    charIndex++;

    const cond = {
      setRules    : ch.setRules.map(r => ({
        id    : setIdMap.get(r.name),
        count: r.count
      })),
      sandMain    : ch.sandMain,
      gobletMain  : ch.gobletMain,
      circletMain : ch.circletMain,
      erRequired  : ch.erRequired,
      erFromOther : 0,
      crMax       : ch.crMax,
      scoreFn     : ch.scoreFn
    };

    const base = i / totalChars;
    const span = 1 / totalChars;

    const {
      best, foundAny, minER, maxCR,
      hasSetOK, hasEROK, hasCROK,
      bestMinCR, bestMaxER
    } = await findBestBuildCase(
        data,
        cond,
        p => {
          const g = round1(base + round1(p * span));
          bar.value = g;
          text.textContent = (g * 100).toFixed(1) + "%";
        },
        setIdCount
      );

    if (!foundAny) {

      const reasons = [];

      const setText = ch.setRules
        .map(r => r.name + (r.count === 4 ? "4" : "2"))
        .join("+");

      // まずセット可否を最優先で判定
      if (!hasSetOK) {
        reasons.push(`・セット効果を組める組み合わせがない`);
      } else {
        if (!hasCROK) {reasons.push(`・会心率過剰 (暫定最低値:${round1(bestMinCR).toFixed(1)} / 上限:${round1(maxCR).toFixed(1)})`);}
        if (!hasEROK) {reasons.push(`・元素チャージ効率不足 (暫定最高値:${round1(bestMaxER).toFixed(1)} / 下限:${round1(minER).toFixed(1)})`);}
      }

      result += `<table border="1" style="margin:2rem auto;">
        <tr>
          <th>
            ${ch.name}<br>(${ch.scoreExpr})
          </th>
        </tr>
        <tr>
          <td>
            条件を満たす組み合わせが見つかりません (${setText})<br>
            ${reasons.join("<br>")}
          </td>
        </tr>
        </table>`;

      continue;
    }

    const sum = sumSubStats(best.list);

    result += `<table border="1" style="margin:2rem auto;">
    <tr>
      <th colspan="10">
        ${ch.name}<br>スコア:${round1(best.total).toFixed(1)} (${ch.scoreExpr})
      </th>
    </tr>
    <tr style="text-align:center;">
      <td>HP+</td><td>HP%</td>
      <td>ATK+</td><td>ATK%</td>
      <td>DEF+</td><td>DEF%</td>
      <td>会心率</td>
      <td>会心<br>ダメージ</td>
      <td>元素熟知</td>
      <td>元素チャージ<br>効率</td>
    </tr>
    <tr style="text-align:center;">
      <td>${round1(sum.hpFlat).toFixed(0)}</td>
      <td>${round1(sum.hpRate).toFixed(1)}</td>
      <td>${round1(sum.atkFlat).toFixed(0)}</td>
      <td>${round1(sum.atkRate).toFixed(1)}</td>
      <td>${round1(sum.defFlat).toFixed(0)}</td>
      <td>${round1(sum.defRate).toFixed(1)}</td>
      <td>${round1(best.crSum).toFixed(1)}<br>(上限:${round1(maxCR).toFixed(1)})</td>
      <td>${round1(sum.cdRate).toFixed(1)}</td>
      <td>${round1(sum.emFlat).toFixed(0)}</td>
      <td>${round1(best.erSum).toFixed(1)}<br>(下限:${round1(minER).toFixed(1)})</td>
    </tr>
    <tr>
      <td colspan="10">
    `;

    for(const a of best.list){
      result +=
        `${a.slot} / ${a.set} / ${a.main} / ${buildSubOpText(a)}<br>`;
    }

    result += `
      </td>
    </tr>
    </table>`;

    const used = new Set(best.list.map(x => x.id));
    data = data.filter(x => !used.has(x.id));
  }

  bar.value = 1;
  text.textContent = "完了";

  document.getElementById("result").innerHTML = result;
});

/* ------------------------------
   ★CSV → Firebase リアルタイム保存
------------------------------ */
const chkReduceCrExpr = document.getElementById("chkReduceCrExpr");
const chkReduceErExpr = document.getElementById("chkReduceErExpr");

const artifactArea  = document.getElementById("artifact");
const characterArea = document.getElementById("character");

const userInput = document.getElementById("username");
const showBtn   = document.getElementById("showUser");
const currentUserNameSpan = document.getElementById("currentUserName");


/* -----------------------------
   checkbox 共通バインド
----------------------------- */
function bindCheckbox(path, checkbox){

  const r = ref(db, path);

  // Firebase → UI（常に Firebase を正とする）
  onValue(r, snap => {

    const v = !!snap.val();

    if (checkbox.checked !== v){
      checkbox.checked = v;
    }
  });

  // UI → Firebase
  checkbox.addEventListener("change", () => {
    set(r, checkbox.checked);
  });
}


/* -----------------------------
   textarea 共通バインド
----------------------------- */
function bindTextarea(path, textarea){

  const r = ref(db, path);

  let isRemote = false;

  // Firebase → textarea
  const unsub = onValue(r, snap => {

    const v = snap.val() ?? "";

    if (textarea.value !== v){

      isRemote = true;
      textarea.value = v;
      isRemote = false;

      textarea.dispatchEvent(new Event("input"));
    }

    textarea.disabled = false;
  });

  // textarea → Firebase
  const onInput = () => {

    if (isRemote) return;

    set(r, textarea.value);
    renderCsvEditors();
  };

  textarea.addEventListener("input", onInput);

  return () => {
    unsub();
    textarea.removeEventListener("input", onInput);
  };
}


/* -----------------------------
   接続処理
----------------------------- */
let unsubArtifact  = null;
let unsubCharacter = null;

showBtn.addEventListener("click", () => {

  const username = userInput.value.trim();
  if(!username){
    alert("usernameを入力してください");
    return;
  }

  currentUserNameSpan.textContent =
    `接続中のユーザー名：${username}`;

  artifactArea.disabled  = true;
  characterArea.disabled = true;

  if(unsubArtifact)  unsubArtifact();
  if(unsubCharacter) unsubCharacter();

  unsubArtifact = bindTextarea(
    `${username}/artifact`,
    artifactArea
  );

  unsubCharacter = bindTextarea(
    `${username}/character`,
    characterArea
  );

  bindCheckbox(
    `${username}/_checkbox/critrate`,
    chkReduceCrExpr
  );

  bindCheckbox(
    `${username}/_checkbox/energyrecharge`,
    chkReduceErExpr
  );
});
</script>

<div style="margin:3rem auto;padding:2rem;width:800px;max-width:80%;max-height:400px;overflow-y:scroll;border:1px solid #888;" class="updatehistory">
	<div style="text-align:center;font-size:1.5rem;font-weight:bold;margin:1rem;">更新履歴</div>

	<div class="version">v1.2.0<span>2026/02/28</span></div>
	<div class="details">
		<p>キャラ情報の入力欄に見出しの機能を追加しました。行頭に「#」を用いることで、その行は見出しとして扱われます</p>
		<p>計算結果にスコア計算式の表示を追加しました</p>
		<p>計算結果において条件を満たす組み合わせが見つからない時、その原因を表示するようにしました</p>
		<p>計算結果のサブOPの並び順を修正しました</p>
		<p>計算結果のレイアウトを調整しました</p>
	</div>

	<div class="version">v1.1.0<span>2026/02/26</span></div>
	<div class="details">
		<p>会心率と元素チャージ効率の初期値を考慮するボタンを追加しました。このボタンの押下状況はユーザーごとに保存されます</p>
		<p>聖遺物情報とキャラ情報の入力欄にコメントアウトの機能を追加しました。「//」を用いることで、その行の終わりまでコメントとして記述ができます</p>
		<p>計算結果のUIを調整し、すべてのサブOP量が表示されるようにしました</p>
		<p>計算結果の一部数値がごく稀に0になってしまう問題を修正しました</p>
		<p>計算結果のサブOP欄にHP+/攻撃力+/防御力+が表示されない問題を修正しました</p>
		<p>その他軽微な変更・修正をしました</p>
	</div>

	<div class="version">v1.0.1<span>2026/02/25</span></div>
	<div class="details">
		<p>現在どのユーザー名で接続しているかを表示するようにしました</p>
		<p>連続で複数のユーザー名に接続した時、前後に接続したユーザーの情報が上書きされてしまうことがある問題の回避策を実装しました</p>
	</div>

	<div class="version">v1.0.0<span>2026/02/25</span></div>
	<div class="details">
		<p>公開しました</p>
	</div>
</div>
</body></html>
